<Project>
    <PropertyGroup>
        <!--
            There is an issue with the ordering of included props files since the $(RootNamespace) property is defined
            in "Microsoft.NET.Sdk.props" but when the Larcanum.GitInfo package is referenced, the package props file
            is added _before_ that definition, so instead of defining this property in the props file, we define it
            in the targets which is included much later after all the props.
        -->
        <GitInfoNamespace Condition="'$(GitInfoNamespace)' == ''">$(RootNamespace)</GitInfoNamespace>
    </PropertyGroup>

    <Target Name="GitInfoCheckBinary">
        <!--
            Checks if the $(GitInfoGitBin) can be resolved to an actual binary and generates the _first_ GitInfoDataLine
            which contains the path the the resolved git binary. If the git binary cannot be found, this generates
            an error.
        -->
        <PropertyGroup>
            <GitIsPath Condition="$(GitInfoGitBin.Contains('\')) OR $(GitInfoGitBin.Contains('/'))">true</GitIsPath>
            <LookupCmd Condition="'$(OS)' == 'Windows_NT'">where</LookupCmd>
            <LookupCmd Condition="'$(OS)' != 'Windows_NT'">which</LookupCmd>
        </PropertyGroup>

        <Error Condition="'$(GitIsPath)' == 'true' AND !Exists('$(GitInfoGitBin)')"
               Text="Git binary path '$(GitInfoGitBin)' does not exist." />

        <Exec Condition="'$(GitIsPath)' != 'true'"
              Command="$(LookupCmd) $(GitInfoGitBin)"
              EchoOff="true"
              ConsoleToMsBuild="true"
              StandardOutputImportance="low"
              IgnoreExitCode="true">
            <Output TaskParameter="ConsoleOutput" ItemName="_GitInfoGitBinResolved" />
            <Output TaskParameter="ExitCode" PropertyName="_GitLookupExitCode" />
        </Exec>

        <Error Condition="'$(GitIsPath)' != 'true' AND ('$(_GitLookupExitCode)' != '0' OR '%(_GitInfoGitBinResolved.Identity)' == '')"
               Text="Could not locate git ('$(GitInfoGitBin)'). Not found on PATH." />

        <ItemGroup>
            <GitInfoDataLine Condition="'$(GitIsPath)' == 'true'" Include="GitPath|debug|$(GitInfoGitBin)" />
            <!--
                Note that on Windows, the 'where' command can return multiple results, separated by newlines.
                We always take the first match here with "%".
            -->
            <GitInfoDataLine Condition="'$(GitIsPath)' != 'true'" Include="GitPath|debug|%(_GitInfoGitBinResolved.Identity)" />
        </ItemGroup>

        <Message Text="GitInfoCheckBinary %(GitInfoDataLine.Identity)" Importance="normal" />
    </Target>

    <Target Name="GitInfoFingerprintFile" DependsOnTargets="GitInfoCheckBinary">
        <!--
            This target creates a "GitInfo.fingerprint.txt" with the last output of the following git command
            which serves as a fingerprint to detect when the GitInfo class should be re-generated during the build.
            The target runs _before_ every build, but most IDEs do their own trickery with optimizations to avoid
            doing an actual Build whenever possible which can lead to a somewhat stale fingerprint file.
        -->
        <Exec Command="$(GitInfoGitBin) describe --tags --always --dirty"
              EchoOff="true"
              ConsoleToMsBuild="true"
              ContinueOnError="true"
              IgnoreExitCode="true"
              StandardErrorImportance="low"
              StandardOutputImportance="low"
              StdOutEncoding="utf-8"
              WorkingDirectory="$(ProjectDir)">
            <Output TaskParameter="ConsoleOutput" PropertyName="_GitFingerprint" />
            <Output TaskParameter="ExitCode" PropertyName="_GitExitCode" />
        </Exec>

        <!--
            If the output of the command changes compared to the previous file contents, then the file will be written
            which will trigger the source generator.
        -->
        <WriteLinesToFile
                Condition="'$(_GitExitCode)' == '0'"
                File="$(IntermediateOutputPath)GitInfo.fingerprint.txt"
                Lines="$(_GitFingerprint)"
                Overwrite="true"
                WriteOnlyWhenDifferent="true" />

        <Message Text="GitInfoFingerprintFile $(_GitFingerprint)" Importance="normal" />
    </Target>

    <Target Name="GitInfoCollect" BeforeTargets="BeforeBuild" DependsOnTargets="GitInfoFingerprintFile" Inputs="@(GitInfoFingerprint)" Outputs="@(GitInfoFingerprint -> '%(RelativeDir)GitInfo.data.txt')">
        <!--
            This target collects the actual git information that is used to eventually generate the source file for GitInfo.
            It does this by running the git command with each GitInfoCommandItem->Args and attaching the output of that
            command to the item itself. After that, it generates GitInfoDataLine items of the form "Name|Type|Value" for
            each of the GitInfoCommandItem values and writes all of those items to the GitInfo.data.txt file.
        -->
        <RunGitCommand Input="@(GitInfoCommandItem)"
                       GitBin="$(GitInfoGitBin)"
                       WorkingDir="$(ProjectDir)">
            <Output TaskParameter="Result" ItemName="_GitInfoDataItem" />
        </RunGitCommand>

        <ItemGroup>
            <GitInfoDataLine Include="%(_GitInfoDataItem.Identity)|%(_GitInfoDataItem.Type)|%(_GitInfoDataItem.Data)" />
        </ItemGroup>

        <WriteLinesToFile
                File="@(GitInfoFingerprint -> '%(RelativeDir)GitInfo.data.txt')"
                Lines="@(GitInfoDataLine)"
                Overwrite="true"
                WriteOnlyWhenDifferent="true" />

        <Message Text="@(GitInfoFingerprint -> '%(RelativeDir)GitInfo.data.txt')" Importance="normal" />
    </Target>

    <Target Name="GitInfoVersion" BeforeTargets="BeforeBuild" Condition="'$(Version)' == '1.0.0' and '$(GitInfoUpdateVersionProp)' == 'true'">
        <!--
            This target sets the $(Version) property based on the git tag description. It uses the same git command as
            the source generator. The target only runs if the $(GitInfoUpdateVersionProp) is enabled AND the $(Version)
            property still has its default value of "1.0.0" which means that it is still possible to override the
            version by specifying it in the project file or passing it via the command line.
        -->
        <Exec Command="$(GitInfoGitBin) describe --tags --always"
              EchoOff="true"
              ConsoleToMsBuild="true"
              ContinueOnError="true"
              IgnoreExitCode="true"
              StandardErrorImportance="low"
              StandardOutputImportance="low"
              StdOutEncoding="utf-8"
              WorkingDirectory="$(ProjectDir)">
            <Output TaskParameter="ConsoleOutput" PropertyName="_GitTag" />
            <Output TaskParameter="ExitCode" PropertyName="_GitExitCode" />
        </Exec>

        <PropertyGroup>
            <!--
                If anything goes wrong or the tag description doesn't contain a semantic version, fall back to using 1.0.0 as the version.
            -->
            <Version Condition="'$(_GitExitCode)' != '0' or !$([System.Text.RegularExpressions.Regex]::IsMatch('$(_GitTag)', '$(GitInfoVersionRegex)'))">1.0.0</Version>
            <!--
                If the tag matches the GitInfoVersionRegex, then we effectively just strip out the prefix since the
                rest is a valid version number in the context of the build.
            -->
            <Version Condition="'$(_GitExitCode)' == '0' and $([System.Text.RegularExpressions.Regex]::IsMatch('$(_GitTag)', '$(GitInfoVersionRegex)'))"
                >$([System.Text.RegularExpressions.Regex]::Replace($(_GitTag), $(GitInfoVersionRegex), "${VERSION}"))</Version>

            <PackageVersion Condition="'$(PackageVersion)' == '1.0.0'">$(Version)</PackageVersion>
        </PropertyGroup>

        <Message Text="GitInfo updated Version to '$(Version)' based on git tag '$(_GitTag)'" Importance="normal" />
    </Target>

    <UsingTask
            TaskName="RunGitCommand"
            TaskFactory="RoslynCodeTaskFactory"
            AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
        <!--
            Running a command and associating its output with an item is not something that can be easily done with
            built-in MSBuild tasks, so we do this with a custom UsingTask. The code is very simple and just runs
            the _GitBin_ command with the arguments from the _Input_ in the given _WorkingDir_ and returns a set of
            items that match the _Input_ but with the additional "Data" metadata containing the command output.
        -->
        <ParameterGroup>
            <GitBin ParameterType="System.String" Required="true" />
            <WorkingDir ParameterType="System.String" Required="true" />
            <Input ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
            <Result ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
        </ParameterGroup>

        <Task>
            <Using Namespace="System" />
            <Using Namespace="System.Diagnostics" />
            <Using Namespace="Microsoft.Build.Framework" />
            <Using Namespace="Microsoft.Build.Utilities" />

            <Code Type="Fragment" Language="cs"><![CDATA[
            foreach (var item in Input)
            {
                var procInfo = new ProcessStartInfo
                {
                    FileName = GitBin,
                    WorkingDirectory = WorkingDir,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    Arguments = item.GetMetadata("Args"),
                };

                var process = Process.Start(procInfo)!;
                process.WaitForExit();

                if (item.GetMetadata("CommandBehavior") == "ExitCode")
                {
                    item.SetMetadata("Data", process.ExitCode == 0 ? "true" : "false");
                }
                else if (item.GetMetadata("CommandBehavior") == "ExitCodeInverted")
                {
                    item.SetMetadata("Data", process.ExitCode == 0 ? "false" : "true");
                }
                else
                {
                    item.SetMetadata("Data", process.ExitCode == 0
                        ? process.StandardOutput.ReadToEnd().Trim()
                        : process.StandardError.ReadToEnd().Trim());
                }
            }

            Result = Input;
            ]]></Code>
        </Task>
    </UsingTask>
</Project>
